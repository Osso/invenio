## BibMerge - figure merging for Invenio

import os
import re
import sys
import codecs
import datetime
import base64
import cPickle

from invenio.textutils import translate_latex2unicode
from invenio.config import CFG_ETCDIR
from invenio.bibtask import write_message
from invenio.bibfigure import output_record, \
				parse_record, \
				output_string, \
				parse_json, \
				Figure
from invenio.bibfigure_utils import levenshtein, \
					backTrack, \
					iterative, \
					LCS, \
					strip_control_characters
									
# TODO: An extractor outputs an image and the other outputs 2 images(half images that
# together create one image)


def merging_articles(file_xml, file_json, id_fulltext, extracted):
	"""
    Function that merges two files

    @param file_xml: file that is generated by Plot extractor
    @param file_json: file that is generated by PDF extractor

    @return: code={0-latex and pdf figures extracted, 1-latex figures not present, 2-pdf figures not present or latex&pdf figures not present},
     		 message - any error messages, the vector of all figures and the first caption for testing purposes as: (exitcode, err_msg)
    """    

	(code, message, list_of_figures_from_latex, list_of_figures_from_pdf) = getFigureVectors(file_xml, file_json)
	(tuples, to_avoid_tuples, updated_list_latex, updated_list_pdf) = doMatching(list_of_figures_from_latex, list_of_figures_from_pdf)
		
for figure in list_of_figures_from_latex:
	write_message("Fig latex with caption[%s]\n"%figure.caption)
	for i in range(len(figure.files)):
		write_message("Fig latex with path[%s]\n"%figure.files[i].path)

	
for figure in list_of_figures_from_pdf:
	write_message("Fig pdf with caption[%s]\n"%figure.caption)
	for i in range(len(figure.files)):
		write_message("Fig pdf with path[%s]\n"%figure.files[i].path)

write_message(tuples)
write_message("\n")
write_message(to_avoid_tuples)
write_message("\n")
write_message("End")
write_message("\n")

# list of figures after merging the lists from latex and pdf
figures = doMerging(tuples, to_avoid_tuples, list_of_figures_from_latex, list_of_figures_from_pdf)
#first_caption = figures[0].caption
first_caption = ""
marc_path = create_MARCXML(figures, id_fulltext, code, extracted, True)

return (code, message, figures, first_caption, marc_path)


def create_MARCXML(figures, id_fulltext, code, extracted, write_file=True):
"""
Function that creates a file MARCXML from the vector of figures

@param figures: the list of all figures
@param id_fulltext: the id of the fulltext
@param code: The code for Latex, PDF or both 
@param extracted: where the file will be generated
@param write_file: it's True when the user wants to write the data into file

@return: the path to the MARCXML file 
"""
both_doc = 0
no_latex = 1
no_pdf = 2
list = []
list.append('<?xml version="1.0" encoding="UTF-8"?>')
list.append('<collection>')
list.append('<record>')

figure_number = 1
for figure in figures:
	
	for i in range(len(figure.files)):
			text_references = ""
			if not figure.files[i].path.endswith("context"):
				list.append('    <datafield tag="FFT" ind1=" " ind2=" ">')
				list.append('      <subfield code="a">' + figure.files[i].path + '</subfield>')
				list.append('      <subfield code="r">restricted_pict</subfield>')
				list.append('      <subfield code="n">' + figure.identifier + '</subfield>')
				list.append('      <subfield code="d">' + figure.caption + '</subfield>')
				if i == 0:
					list.append('      <subfield code="i">TMP:' + str(id_fulltext) + ':' + str(figure_number) + '</subfield>')
					list.append('      <subfield code="v">TMP:' + str(id_fulltext) + ':v' + str(figure_number) + '</subfield>')
				list.append('    </datafield>')
				
			else:
				text_references = figure.text_references
			if i < len(figure.files)-1:
				list.append('\n')
#			if i == len(figure.files) - 1:
#				list.append('  </record>')
			# if we have the fulltext pdf we add the BRT tag after the FFT tag
			if code != no_pdf and i == len(figure.files) - 1:
				list.append('  <datafield tag="BRT" ind1=" " ind2=" ">')
				list.append('	<subfield code="i">TMP:OAI:' + str(figure_number) + '</subfield>')
				list.append('	<subfield code="v">TMP:OAI:' + str(figure_number) + '</subfield>')
				list.append('	<subfield code="j">TMP:' + str(id_fulltext) + '</subfield>')
				list.append('	<subfield code="w">TMP:' + str(id_fulltext) + '</subfield>')
				list.append('	<subfield code="t">is_extracted_from</subfield>')
				dict = {}
				dict["figures"]={}
				dict["figures"]["caption"]=figure.caption
				v = ["location", "caption_location"]				
				for i, item in enumerate(v):
					if(figure.get_location(i) != None):
						dict["figures"][item]={}
						dict["figures"][item]["page_num"] = figure.get_location(i).page_num
						if(figure.get_location(i).page_resolution != None):
							dict["figures"][item]["page_resolution"]={}
							dict["figures"][item]["page_resolution"]["width"]=figure.get_location(i).page_resolution.width
							dict["figures"][item]["page_resolution"]["height"]=figure.get_location(i).page_resolution.height
						if(figure.get_location(i).boundary != None):
							dict["figures"][item]["boundary"]={}
							dict["figures"][item]["boundary"]["width"]=figure.get_location(i).boundary.width
							dict["figures"][item]["boundary"]["height"]=figure.get_location(i).boundary.height
							dict["figures"][item]["boundary"]["x"]=figure.get_location(i).boundary.x
							dict["figures"][item]["boundary"]["y"]=figure.get_location(i).boundary.y
						if i==0:
							dict["figures"][item]["page_scale"]=figure.get_location(i).page_scale
				dict["figures"]["text_references"] = text_references
				
				d = cPickle.dumps(dict)
				info = base64.encodestring(d)
				list.append('	<subfield code="m">' + info + '</subfield>')
			
			list.append('  </datafield>')
		figure_number = figure_number + 1
	list.append('</record>')
	list.append('</collection>')
	marc = '\n'.join(list)
	if write_file:
		marc_path = str(extracted) + "/extracted.xml"
		f = codecs.open(marc_path, encoding="utf-8", mode="a")
		#f = open(marc_path, 'a')
		f.write(marc)
		f.close()
	return marc_path


'''
def create_MARCXML(figures, id, write_file=True):
	"""
	Function that creates a file MARCXML from the vector of figures
	
	@param figures: the list of all figures
	@param id: the id of the arXiv source where the file will be generated
	@param write_file: it's True when the user wants to write the data into file
	
	@return: the path to the MARCXML file 
	"""
	list = []
	list.append('<?xml version="1.0" encoding="UTF-8"?>')
	list.append('<collection>')
	list.append('<record>')
	
	for figure in figures:
		for i in range(len(figure.files)):
			list.append('  <datafield tag="FFT" ind1=" " ind2=" ">')
			list.append('    <subfield code="a">' + figure.files[i].path + '</subfield>')
			list.append('    <subfield code="t">Figure</subfield>')
			if i == 0:
				# TODO: if figure caption contains xml
				list.append('    <subfield code="d">' + figure.caption + '</subfield>')
			if i == len(figure.files) - 1:
				filenames = []
				for j in range(len(figure.files)):
					filenames.append(figure.files[j].filetype)
				list.append('    <subfield code="f">' + ';'.join(filenames) + '</subfield>')
			
			
			#here insert the TMP id and the version
			list.append('    <subfield code="n">' + figure.identifier + '</subfield>')
			if i == 0:
				# the status field can be seen only in the file extracted by latex plotextractor,
				# so if we take a figure from json file, the figure.status will be obvious None and
				# we don't write it in the final MARCXML
				if(figure.status != None):
					list.append('    <subfield code="o">' + str(figure.status) + '</subfield>')
			list.append('  </datafield>')
	list.append('</record>')
	list.append('</collection>')
	marc = '\n'.join(list)
	if write_file:
		marc_path = str(id) + "/extracted.xml"
		f = codecs.open(marc_path, encoding="utf-8", mode="a")
		#f = open(marc_path, 'a')
		f.write(marc)
		f.close()
	return marc_path
'''


def doMerging(tuples, to_avoid_tuples, list_of_figures_from_latex, list_of_figures_from_pdf):
	"""
	Function that merges the lists of figures, taking in account tuples and to avoid tuples
	
	@param tuples: the index of figures that are the same
	@param to_avoid_tuples: the index of figures that we should remove, is an "arrow" concept
	@param list_of_figures_from_latex: the list of all figures that come from latex extractor
	@param list_of_figures_from_pdf: the list of all figures that come from pdf extractor
	
	@return: the list of figures after merging process 
	"""
	outputVector = []

	for a_tuple in tuples:
		index_figure_latex = a_tuple[0]
		index_figure_pdf = a_tuple[1]
		
		figure_pdf = list_of_figures_from_pdf[index_figure_pdf]
		id = figure_pdf.identifier
		s_d = figure_pdf.source_document
		c = figure_pdf.caption
		c_f = figure_pdf.caption_file
		f = figure_pdf.files
		l = figure_pdf.location
		c_l = figure_pdf.caption_location
		a_i = figure_pdf.annotated_image
		
		figure_latex = list_of_figures_from_latex[index_figure_latex]
		for index, a_file in enumerate(figure_latex.files):
			if index != 0:
				f.append(a_file)
		
		s = figure_latex.status
		t_r = figure_latex.text_references

		# or create a class for a final figure with the fields we are interested
		outputVector.append(Figure(identifier=id, source_document=s_d, caption=c, caption_file=c_f, files=f, location=l, caption_location=c_l, annotated_image=a_i, status=s, text_references=t_r))

	index_latex_figures = [a_tuple[0] for a_tuple in tuples]
	index_avoid_latex_figures = [a_tuple[0] for a_tuple in to_avoid_tuples]
	for index, figure in enumerate(list_of_figures_from_latex):
		if index not in index_latex_figures and index not in index_avoid_latex_figures:  
				id = figure.identifier
				c = figure.caption
				f = figure.files
				s = figure.status
				t_r = figure.text_references
				outputVector.append(Figure(identifier=id, caption=c, files=f, status=s, text_references=t_r))		
	
	index_pdf_figures = [a_tuple[1] for a_tuple in tuples]
	index_avoid_pdf_figures = [a_tuple[1] for a_tuple in to_avoid_tuples]
	for index, figure in enumerate(list_of_figures_from_pdf):
		if index not in index_pdf_figures and index not in index_avoid_pdf_figures:
			id = figure.identifier
			s_d = figure.source_document
			c = figure.caption
			c_f = figure.caption_file
			f = figure.files
			l = figure.location
			c_l = figure.caption_location
			a_i = figure.annotated_image
			outputVector.append(Figure(identifier=id, source_document=s_d, caption=c, caption_file=c_f, files=f, location=l, caption_location=c_l, annotated_image=a_i))
	return outputVector


'''
def doMerging(tuples, to_avoid_tuples, list_of_figures_from_latex, list_of_figures_from_pdf):
	"""
	Function that merges the lists of figures, taking in account tuples and to avoid tuples
	
	@param tuples: the index of figures that are the same
	@param to_avoid_tuples: the index of figures that we should remove, is an "arrow" concept
	@param list_of_figures_from_latex: the list of all figures that come from latex extractor
	@param list_of_figures_from_pdf: the list of all figures that come from pdf extractor
	
	@return: the list of figures after merging process 
	"""
	outputVector = []
	clone_list_latex = list_of_figures_from_latex[:]
	clone_list_pdf = list_of_figures_from_pdf[:]

	for a_tuple in tuples:
		index_figure_latex = a_tuple[0]
		index_figure_pdf = a_tuple[1]
		
		figure_pdf = list_of_figures_from_pdf[index_figure_pdf]
		id = figure_pdf.identifier
		s_d = figure_pdf.source_document
		c = figure_pdf.caption
		c_f = figure_pdf.caption_file
		f = figure_pdf.files
		l = figure_pdf.location
		c_l = figure_pdf.caption_location
		a_i = figure_pdf.annotated_image
		
		figure_latex = list_of_figures_from_latex[index_figure_latex]
		for a_file in figure_latex.files:
			f.append(a_file)
		
		s = figure_latex.status
		t_r = figure_latex.text_references

		# or create a class for a final figure with the fields we are interested
		outputVector.append(Figure(identifier=id, source_document=s_d, caption=c, caption_file=c_f, files=f, location=l, caption_location=c_l, annotated_image=a_i, status=s, text_references=t_r))
		# delete the figures in the vectors
		clone_list_pdf.remove(figure_pdf)
		clone_list_latex.remove(figure_latex)
		
	for a_tuple in to_avoid_tuples:
		index_figure_latex = a_tuple[0]
		index_figure_pdf = a_tuple[1]
		
		figure_pdf = list_of_figures_from_pdf[index_figure_pdf]
		figure_latex = list_of_figures_from_latex[index_figure_latex]
		if(figure_pdf in clone_list_pdf):
			# remove the information in CLONE_LIST
			clone_list_pdf.remove(list_of_figures_from_pdf[index_figure_pdf])
		if(figure_latex in clone_list_latex):
			clone_list_latex.remove(list_of_figures_from_latex[index_figure_latex])
		
	for figure in clone_list_pdf:
		id = figure.identifier
		s_d = figure.source_document
		c = figure.caption
		c_f = figure.caption_file
		f = figure.files
		l = figure.location
		c_l = figure.caption_location
		a_i = figure.annotated_image
		outputVector.append(Figure(identifier=id, source_document=s_d, caption=c, caption_file=c_f, files=f, location=l, caption_location=c_l, annotated_image=a_i))
		
	for figure in clone_list_latex:
		id = figure.identifier
		c = figure.caption
		f = figure.files
		s = figure.status
		t_r = figure.text_references
		outputVector.append(Figure(identifier=id, caption=c, files=f, status=s, text_references=t_r))
	return outputVector
'''

'''
# TODO: when having a pdf and a latex, the caption from the pdf is taken. So if the caption of the pdf is empty,
# it should take actually the caption of the latex source 
def doMerging(tuples, to_avoid_tuples, list_of_figures_from_latex, list_of_figures_from_pdf):
	"""
	Function that merges the lists of figures, taking in account tuples and to avoid tuples
	
	@param tuples: the index of figures that are the same
	@param to_avoid_tuples: the index of figures that we should remove, is an "arrow" concept
	@param list_of_figures_from_latex: the list of all figures that come from latex extractor
	@param list_of_figures_from_pdf: the list of all figures that come from pdf extractor
	
	@return: the list of figures after merging process 
	"""
	outputVector = []
	clone_list_latex = list_of_figures_from_latex[:]
	clone_list_pdf = list_of_figures_from_pdf[:]

	for a_tuple in tuples:
		index_figure_latex = a_tuple[0]
		index_figure_pdf = a_tuple[1]
		
		figure_pdf = list_of_figures_from_pdf[index_figure_pdf]
		identifier = figure_pdf.identifier
		sourceDocument = figure_pdf.sourceDocument
		caption = figure_pdf.caption
		captionFile = figure_pdf.captionFile
		files = figure_pdf.files
		location = figure_pdf.location
		captionLocation = figure_pdf.captionLocation
		annotatedImage = figure_pdf.annotatedImage
		
		figure_latex = list_of_figures_from_latex[index_figure_latex]
		for a_file in figure_latex.files:
			files.append(a_file)
		
		status = figure_latex.status
		text_references = figure_latex.text_references

		# or create a class for a final figure with the fields we are interested
		outputVector.append(Figure(identifier, sourceDocument, caption, captionFile, files, location, captionLocation, annotatedImage, status, text_references))
		# delete the figures in the vectors
		clone_list_pdf.remove(figure_pdf)
		clone_list_latex.remove(figure_latex)
		
	for a_tuple in to_avoid_tuples:
		index_figure_latex = a_tuple[0]
		index_figure_pdf = a_tuple[1]
		
		figure_pdf = list_of_figures_from_pdf[index_figure_pdf]
		figure_latex = list_of_figures_from_latex[index_figure_latex]
		if(figure_pdf in clone_list_pdf):
			# remove the information in CLONE_LIST
			clone_list_pdf.remove(list_of_figures_from_pdf[index_figure_pdf])
		if(figure_latex in clone_list_latex):
			clone_list_latex.remove(list_of_figures_from_latex[index_figure_latex])
		
	for figure in clone_list_pdf:
		status = text_references = None
		identifier = figure.identifier
		sourceDocument = figure.sourceDocument
		caption = figure.caption
		captionFile = figure.captionFile
		files = figure.files
		location = figure.location
		captionLocation = figure.captionLocation
		annotatedImage = figure.annotatedImage
		outputVector.append(Figure(identifier, sourceDocument, caption, captionFile, files, location, captionLocation, annotatedImage, status, text_references))
		
	for figure in clone_list_latex:
		sourceDocument = captionFile = location = captionLocation = annotatedImage = None
		identifier = figure.identifier
		sourceDocument = figure.sourceDocument
		caption = figure.caption
		captionFile = figure.captionFile
		files = figure.files
		location = figure.location
		captionLocation = figure.captionLocation
		annotatedImage = figure.annotatedImage
		status = figure.status
		text_references = figure.text_references
		outputVector.append(Figure(identifier, sourceDocument, caption, captionFile, files, location, captionLocation, annotatedImage, status, text_references))
	return outputVector
'''
def doMatching(list_latex, list_pdf):
	"""
	Function that compares all the figures in the list pdf with those in the list latex (levenshtein distance)
	If are identical, create a tuple (index, index)
	The comparison is made by the image caption
	
	@param list_latex: the list with all figures fom latex source
	@param list_pdf: the list with all figures from pdf source
	
	@return: the matching tuples and the tuples to avoid
	"""
	#tuples, updated_list_latex, updated_list_pdf = similarity(list_latex, list_pdf)
	distances, updated_list_latex, updated_list_pdf = similarity(list_latex, list_pdf)
	tuples = []
	to_avoid_tuples = []
	
	list_of_index_list = []
	for i in range(len(list_pdf)):
		index_list = [distance[i] for distance in distances]
		list_of_index_list.append(index_list)
	
	for i in range(len(list_of_index_list)):
		if len(list_of_index_list[i]) != 0:
			min_value = min(list_of_index_list[i])
			index_min_value = list_of_index_list[i].index( min_value )
			tuples.append((index_min_value, i))
	
	write_message("!!!!!!!11")
	write_message( tuples )
	write_message("!!!!!!!11")
	to_remove = []
	for tuple_i in tuples:
		for tuple_j in tuples:

			i = tuples.index(tuple_i)
			j = tuples.index(tuple_j)
			if(i != j):
				if(tuple_i[0] == tuple_j[0]):
					if(tuple_i not in to_avoid_tuples):
						if(i<j):
							argument = tuple_j[0], tuple_j[1]
							to_avoid_tuples.append(argument)
						if(i>j):
							argument = tuple_i[0], tuple_i[1]
							to_avoid_tuples.append(argument)
				if(tuple_i[1] == tuple_j[1]):
					if(tuple_i not in to_avoid_tuples):
						if(i<j):
							argument = tuple_j[0], tuple_j[1]
							to_avoid_tuples.append(argument)
						if(i>j):
							argument = tuple_i[0], tuple_i[1]
							to_avoid_tuples.append(argument)
					
	# example
	# before tuples was: (1,1), (1,2), (2,3), (4,5), we delete the touple (1,2)
	# tuples : (1,1), (2,3), (4,5)
	# to_avoid_tuples: (1,2)				
	write_message(to_avoid_tuples)
	for a_tuple in to_avoid_tuples:
		tuples.remove(a_tuple)
	to_avoid_tuples = []
	return (tuples, to_avoid_tuples, updated_list_latex, updated_list_pdf)

'''
def doMatching(list_latex, list_pdf):
	"""
	Function that compares all the figures in the list pdf with those in the list latex (levenshtein distance)
	If are identical, create a tuple (index, index)
	The comparison is made by the image caption
	
	@param list_latex: the list with all figures fom latex source
	@param list_pdf: the list with all figures from pdf source
	
	@return: the matching tuples and the tuples to avoid
	"""
	tuples, updated_list_latex, updated_list_pdf = similarity(list_latex, list_pdf)
	to_avoid_tuples = []
	for tuple_i in tuples:
		for tuple_j in tuples:

			i = tuples.index(tuple_i)
			j = tuples.index(tuple_j)
			if(i != j):
				if(tuple_i[0] == tuple_j[0]):
					if(tuple_i not in to_avoid_tuples):
						if(i<j):
							argument = tuple_j[0], tuple_j[1]
							to_avoid_tuples.append(argument)
						if(i>j):
							argument = tuple_i[0], tuple_i[1]
							to_avoid_tuples.append(argument)
				if(tuple_i[1] == tuple_j[1]):
					if(tuple_i not in to_avoid_tuples):
						if(i<j):
							argument = tuple_j[0], tuple_j[1]
							to_avoid_tuples.append(argument)
						if(i>j):
							argument = tuple_i[0], tuple_i[1]
							to_avoid_tuples.append(argument)
	
	# example
	# before tuples was: (1,1), (1,2), (2,3), (4,5), we delete the touple (1,2)
	# tuples : (1,1), (2,3), (4,5)
	# to_avoid_tuples: (1,2)				
	for a_tuple in to_avoid_tuples:
		tuples.remove(a_tuple)
	
	return (tuples, to_avoid_tuples, updated_list_latex, updated_list_pdf)

def similarity(list_latex, list_pdf):
	"""
	The function that takes two lists of figures and detects the matches between them
	
	@param list_latex: the list of latex figures
	@param list_pdf: the list of pdf figures
	
	@return: the matching tuples
	"""
	caption_list_latex = [figure.caption for figure in list_latex]
	caption_list_pdf = [figure.caption for figure in list_pdf]
	
	for index, caption in enumerate(caption_list_latex):
		# transform all latex simbols in unicode
		caption = translate_latex2unicode(caption)
		# remove all spaces and new lines and tabs from the beginning, then if a line contains \n, replace with space
		caption = caption.lstrip().replace('\n', ' ')
		list_latex[index].caption = caption
		# when encounter at the beginning the regular expresion: number => skip
		#ur UNICODE RAW
		caption = re.sub(ur'^[\d]+ ', '', caption)
		caption_list_latex[index] = caption
		
	# Transformations (special characters and newlines)
	for index, caption in enumerate(caption_list_pdf):
		# remove all spaces and new lines and tabs from the beginning, then if a line contains \n, replace with space
		caption = caption.lstrip().replace('\n', ' ')
		caption = strip_control_characters(caption)
		list_pdf[index].caption = caption
		# when encounter at the beginning the regular expresion: Fig. number. => skip
		#ur UNICODE RAW
		caption = re.sub(ur'^Fig\. [\d]+\. ', '', caption)
		caption = re.sub(ur'^Figure [\d]+\: ', '', caption)
	# used for levenshtein distance
	dictionary = {}
	# used for longest common subsequence
	dictionary2 = {}
	# used for direct comparison
	dictionary3 = {}
	new_feature_list = []
	for i in range(len(caption_list_latex)):
		distances = []
		lcss = []
		for j in range(len(caption_list_pdf)):
			distance = levenshtein(caption_list_latex[i], caption_list_pdf[j])
			distances.append(distance)
			X = caption_list_latex[i]
			Y = caption_list_pdf[j]
			m = len(X)
			n = len(Y)
			C = LCS(X, Y)
			lcs = iterative(C, X, Y, m, n)
			lcss.append(lcs)
		new_feature_list.append(distances)
		max_distance = 0
		index_max = 0
		# the list we use in representing the longest common subsequence
		index_max_elem_list = []
		for k in range(len(lcss)):
			if len(lcss[k]) > max_distance:
				max_distance = len(lcss[k])
				index_max = k
		index_max_elem_list.append(index_max)
		# if there are equal distances
		n = 0
		for k in range(len(lcss)):
			if len(lcss[k]) == max_distance:
				if(n != 0):
					index_max_elem_list.append(k)
				n=1
		
		min_distance = 100000
		# the list we use in representing the levenshtein distance
		index_min_elem_list = []
		# the list for direct comparison
		index_min_direct_comparison = []

		for k in range(len(distances)):
			if distances[k] == 0:
				index_min_direct_comparison.append(k)
			if distances[k] < min_distance:
				min_distance = distances[k]
				index_min = k
		if len(distances) != 0:
			index_min_elem_list.append(index_min)
		# if there are equal distances
		n = 0
		for k in range(len(distances)):
			if distances[k] == min_distance:
				if(n != 0):
					index_min_elem_list.append(k)
				n=1
		
		
		dictionary[i] = index_min_elem_list
		print dictionary
		
		dictionary2[i] = index_max_elem_list
		print dictionary2
		
		dictionary3[i] = index_min_direct_comparison
		print dictionary3
	
	tuples = []
	for i in range(len(dictionary)):
		for j in range(len(dictionary.values()[i])):
			if(dictionary.values()[i] == dictionary2.values()[i]):
			# if dictionary.values()[i] == dictionary3.values()[i]
				a_tuple = i, dictionary.values()[i][j]
				tuples.append(a_tuple)
	return new_feature_list, clone_list_latex, clone_list_pdf


def similarity_between_caption1_and_caption2(caption1, caption2, list1, list2):
	"""
	Function that takes two lists and two captions and returns if the caption 1 is matching caption 2
	
	@param caption1: caption from pdf source
	@param caption2: caption from latex source
	@param list1: list of pdf figures
	@param list2: list of latex figures
	
	@return: 0 if caption1 matches caption2, -1 else
	"""

	caption_list1 = [element.caption for element in list1]
	caption_list2 = [element.caption for element in list2]
	
	# Transformations (special characters and newlines)
	for index, caption in enumerate(caption_list1):
		# remove all spaces and new lines and tabs from the beginning, then if a line contains \n, replace with space
		caption = caption.lstrip().replace('\n', ' ')
		# when encounter at the beginning the regular expresion: Fig. number. => skip
		#ur UNICODE RAW
		caption = re.sub(ur'^Fig\. [\d]+\. ', '', caption)
		caption_list1[index] = caption
	print caption_list1
	for index, caption in enumerate(caption_list2):
		# transform all latex simbols in unicode
		caption = translate_latex2unicode(caption)
		# remove all spaces and new lines and tabs from the beginning, then if a line contains \n, replace with space
		caption = caption.lstrip().replace('\n', ' ')
		# when encounter at the beginning the regular expresion: number => skip
		#ur UNICODE RAW
		caption = re.sub(ur'^[\d]+ ', '', caption)
		caption_list2[index] = caption
	print caption_list2	

	# Long common subsequence
	# Levenshtein distance
	dictionary = {}
	dictionary2 = {}
	dictionary3 = {}

	for i in range(len(caption_list1)):
		distances = []
		lcss = []
		for j in range(len(caption_list2)):
			distance = levenshtein(caption_list1[i], caption_list2[j])
			distances.append(distance)
			X = caption_list1[i]
			Y = caption_list2[j]
			m = len(X)
			n = len(Y)
			C = LCS(X, Y)
			lcs = backTrack(C, X, Y, m, n)
			lcss.append(lcs)

		print distances
		max_distance = 0
		index_max_elem_list = []
		for k in range(len(lcss)):
			if len(lcss[k]) > max_distance:
				max_distance = len(lcss[k])
				index_max = k
		index_max_elem_list.append(index_max)
		# if there are equal distances
		n = 0
		for k in range(len(lcss)):
			if len(lcss[k]) == max_distance:
				if(n != 0):
					index_max_elem_list.append(k)
				n=1	
		
		min_distance = 100000
		index_min_elem_list = []
		index_min_direct_comparison = []

		for k in range(len(distances)):
			if distances[k] == 0:
				index_min_direct_comparison.append(k)
			if distances[k] < min_distance:
				min_distance = distances[k]
				index_min = k
		index_min_elem_list.append(index_min)
		# if there are equal distances
		n = 0
		for k in range(len(distances)):
			if distances[k] == min_distance:
				if(n != 0):
					index_min_elem_list.append(k)
				n=1

		dictionary[i] = index_min_elem_list
		print dictionary

		dictionary2[i] = index_max_elem_list
		print dictionary2
		
		dictionary3[i] = index_min_direct_comparison
		print dictionary3
	
	for caption in caption_list1:
		if caption == caption1:
			index_caption1 = caption_list1.index(caption)
	for caption in caption_list2:
		if caption == caption2:
			index_caption2 = caption_list2.index(caption)
	if index_caption2 in dictionary[index_caption1]:
		if index_caption2 in dictionary2[index_caption1]:
	#		if index_caption2 in dictionary3[index_caption1]
			return 0
	return -1

def getFiles(directory):
	"""
	Function that gets all the files from a directory and sorts them
	
	@param directory: the directory
	
	@return: the files
	"""
	listing = os.listdir(directory)
	listing.sort()
	return listing

def getFigureVectors(file_xml, file_json):
	"""
	Function that receives two files, inserts the information in a class Figure and outputs the list of figures
	from json and xml
	
	@param file_xml: the file xml
	@param file_json: the file json
	
	@return: code, message, list of figures from pdf and from latex
	If code is 0, there are no errors, else code is 1
	The error is found in the message
	"""

	code = 0
	message = ''
	# first check if the file exists
	if os.path.exists(file_xml):
		record = output_record(file_xml)
		# if a file xml doesn't contain the record metadata, return the list empty
		if record != None:
			list_of_figures_from_latex = parse_record(record)
		else:
			code = 1
			now = datetime.datetime.now()
			message = "[" + str(now) + "]: " + "the file " + file_xml + " does not contain the metadata record\n"
			list_of_figures_from_latex = []
	# if not, empty list
	else:
		code = 1
		now = datetime.datetime.now()
		message = "[" + str(now) + "]: " + "the file " + file_xml + " does not exist\n"
		list_of_figures_from_latex = []
	
	
	if os.path.exists(file_json):
		json_to_string = output_string(file_json)
		list_of_figures_from_pdf = parse_json(json_to_string)
	# if not, the list is empty
	else:
		code = 2
		now = datetime.datetime.now()
		message = "[" + str(now) + "]: " + "the file " + file_json + " does not exist\n"
		list_of_figures_from_pdf = []
	
		
	return (code, message, list_of_figures_from_latex, list_of_figures_from_pdf)

def main():
	if len(sys.argv) != 3:
		print 'Error on command line parameters. Usage: bibfigure_merge <file1> <file2>'
	else:
		file1 = sys.argv[1]
		file2 = sys.argv[2]
		merging_articles(file1, file2)
	
if __name__== "__main__":
	main()
